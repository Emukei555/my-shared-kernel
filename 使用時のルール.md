## my-shared-kernel 実装ルール（2026年1月現在）

このライブラリは「**型安全で失敗が伝播しやすいコード**」を最優先に設計しています。  
以下のルールは、**DDD + Resultパターン + Railway Oriented Programming**を実践するための指針です。

### 1. 例外は原則禁止 → Result<T> で統一（必須）

- **ルール**:
  - ドメインロジック内で `throw` は禁止（Infrastructure層のみ例外をキャッチしてResultに変換）
  - 失敗は必ず `Result.failure(ErrorCode, message)` で返す
  - 呼び出し側は `flatMap` / `map` / `tap` / `tapFailure` でチェーン処理

- **正しい例**:
  ```java
  public Result<Money> subtract(Money other) {
      if (this.value.compareTo(other.value) < 0) {
          return Result.failure(CommonErrorCode.INSUFFICIENT_FUNDS, "残高不足");
      }
      return Result.success(new Money(this.value.subtract(other.value)));
  }

間違った例（禁止）:java

if (this.value.compareTo(other.value) < 0) {
    throw new IllegalStateException("残高不足");  // NG
}

2. Value Object (VO) はコンストラクタで不変条件をガード（必須）ルール:VOのコンストラクタで即座に不変条件を検証
無効な状態はインスタンス化させない（失敗時は例外 or Result.failure）
原則として**不変（immutable）**にする（record推奨）

例 (Money VO):java
  ```java
public record Money(BigDecimal value) {
    public Money {
        if (value == null) {
            throw new IllegalArgumentException("金額はnullにできません");
        }
        if (value.scale() > 4) {
            throw new IllegalArgumentException("小数点以下4桁まで");
        }
        if (value.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("負の金額は許可されません");
        }
    }

    public Result<Money> add(Money other) {
        return Result.success(new Money(this.value.add(other.value)));
    }

    public Result<Money> subtract(Money other) {
        if (this.value.compareTo(other.value) < 0) {
            return Result.failure(CommonErrorCode.INSUFFICIENT_FUNDS, "残高不足");
        }
        return Result.success(new Money(this.value.subtract(other.value)));
    }
}
  ```
3. flatMap / map / tap / tapFailure の使い分け（必須）メソッド
用途
戻り値
副作用OK?
失敗時も実行?
例
flatMap
  ```
次の処理がResultを返す場合
Result<U>
×
×
.flatMap(this::validateBudget)
map
  ```
成功時の値変換（状態更新など）
  ```java
Result<U>
×
×
.map(newBalance -> { this.balance = newBalance; return this; })
tap
  ```
成功時の副作用（ログ、通知）
  ```java
Result<T>
○
×
.tap(wallet -> log.info("更新成功: {}", wallet.balance))
tapFailure
  ```
失敗時の副作用（ログ、エラー通知）
  ```java
Result<T>
○
○
.tapFailure(f -> log.warn("失敗: {}", f.message()))
  ```

ルール:状態変更はmapの最後にまとめて（チェーン全体が成功してから）
ログはtap / tapFailureで分離（成功/失敗を明確に）

4. エンティティの状態変更ルール（必須）ルール:エンティティの状態変更（this.xxx = ...）はチェーン全体が成功した最後のmapでまとめて行う
失敗したら状態は一切変更しない（不変性を守る）

正しい例:java
``` java
public Result<Account> withdraw(Money amount) {
    return balance.subtract(amount)
        .map(newBalance -> {
            this.balance = newBalance;  // 最後にまとめて更新
            log.debug("出金成功: {} -> {}", balance, newBalance);
            return this;
        })
        .tapFailure(f -> log.warn("出金失敗: {}", f.message()));
}
```
5. ログのルール（推奨）ルール:MDCにrequestId/userIdを必ず入れる（RequestContextFilterで自動化）
成功ログ → tap
失敗ログ → tapFailure
デバッグログはDEBUG、運用ログはINFO/WARN

例:java
``` java
.tap(wallet -> log.debug("残高更新: {} -> {}", oldBalance, wallet.balance))
.tapFailure(f -> log.warn("残高不足: amount={}, current={}", amount, balance))
```
6. 禁止事項リスト（絶対守る）null を返す
Optional を返す（Resultで統一）
例外をドメインロジック内でスロー
Serviceクラスにビジネスロジックを詰め込む（UseCase / Entity に寄せる）
チェーン内で状態変更を途中に挟む（最後にまとめる）
tap で失敗時の処理を書く（tapFailureを使う）

